params {
   // This closure facilitates the usage of sample specific parameters
   parseConfig = { sample, paramsGlobal, paramsLocal ->
         def lv = { a,b -> return org.codehaus.groovy.runtime.MethodRankHelper.delDistance(a, b) }
         def pL = paramsLocal.collectEntries { k,v ->
            if (v instanceof Map) {
               if (v.containsKey(sample))
                  return [k, v[sample]]
               if (v.containsKey('default'))
                  return [k, v['default']]
               def closeMatches = v.collectEntries { vk, vv -> [lv(vk, sample), vk] }.keySet().findAll { it < 30}
               if(closeMatches.size() > 0)
                  throw new Exception("The sample " + sample + " is not found in " + v +" ; Make sure your samples are correctly specified when using the multi-sample feature.")
               else
                  return [k,v]
            } else {
               return [k,v]
         }
      }
      return [global: paramsGlobal, local: pL]
   }
   getToolParams = { toolKey ->
      def _get = { p ->
         if(p.containsKey("tools")) { // weirdly p?.tools gives a WARN (same for the other if statements)
            return p.tools[toolKey]
         }
         if(p.containsKey("sc")) {
            return p.sc[toolKey]
         }
         throw new Exception("VSN ERROR: Cannot get tool params from NXF params.")
      }
      if(!toolKey.contains(".")) {
         return _get(params)
      }
      def entry = null
      if(params.containsKey("tools")) {
         entry = params.tools
      } else if(params.containsKey("sc")) {
         entry = params.sc
      } else {
         throw new Exception("VSN ERROR: Missing params.<sc|tools>.")
      }

      toolKey.split('\\.').each { entry = entry?.get(it) }
      return entry
   }
   hasToolParams = { toolKey ->
      if(params.containsKey("tools")) {
         return params.tools.containsKey(toolKey)
      }
      if(params.containsKey("sc")) {
         return params.sc.containsKey(toolKey)
      }
      return false
   }
}
